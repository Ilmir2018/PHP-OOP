<?php
/**
 * Created by PhpStorm.
 * User: Ilmir
 * Date: 30.10.2018
 * Time: 13:21
 */

namespace app\base;

use app\traits\TSingleton;


/**
 * Class App создан для того чтобы все компоненты приложения зависели от него,
 * только в этом классе мы помещаем Singleton и каждый компонент зависимый от
 * этого класса будет создаваться в единственном экземпляре.
 * Компоненты это свойства приложения App.
 * @property $db;
 * @property $request;
 * @property $session;
 */

class App
{
    //Подключение паттерна проектирования Singleton.
    use TSingleton;

    //Этот метод предназначен для того чтобы вызывать нужный компонент заданный в концигурации
    //без необходимости плодить множество объектов. getInstance() - это функция необходимая для того
    //чтобы создаваемый объект был в единственном экземпляре. Это свойство паттерна проектирования Singleton.
    public static function call()
    {
        return static::getInstance();
    }
    //Создаём побличное свойство чтобы можно было поместить в него переданый в index.php файл конфигурации,
    //который возвращает массив с конфигурациями.
    public $config;
    //Создаём приватное свойство чтобы в нем можно было создать объект для создания компонентов.
    private $components;

    public function run($config)
    {
        //В созданную нами ранее публичную переменную вствляем то что передаётся при вызове метода run
        // от класса App
        $this->config = $config;
        //В созданную нами ранее приватную переменную вставляем объект new Storage() в котором хранятся компоненты.
        $this->components = new Storage();
        //Запускаем метод runController в котором осуществляется обработка передаваемх в браузере данных
        // и отображение необходимого шаблона.
        $this->runController();
    }

    private function runController()
    {
        //$controllerName это первое имя/ в адресной строке. При заходе на сайт стоит имя по умолчанию
        //и оно задаётся в конфигурации папка config, файл main.
        $controllerName = $this->request->getControllerName() ?: $this->config['defaultController'];
        //$actionName это второе имя/ в адресной строке которое по умолчанию index и находится в каждом
        //контроллере. Таких вторых имён для каждого контроллера может быть несколько.
        $actionName = $this->request->getActionName();

        //В переменную помещаем строку, где $this->config['controllerNamespace'] это значение массива, возвращаемое
        //из файла main а ucfirst($controllerName) это имя котороеприходит после выполнения запроса переводимое в
        // верхний регистр
        $controllerClass = $this->config['controllerNamespace'] . "\\" . ucfirst($controllerName) . "Controller";
        //Проверяем существование вызываемого класса.
        if (class_exists($controllerClass)){
            //Здесь происходит принятие решения, какой шаблонизатор мы используем. Мы создаём объект и помещаем его в
            //переменную $controller, чтобы потом от этого объекта вызвать метод для подгрузки шаблона.
            $controller = new $controllerClass(new \app\services\renderers\TemplateRenderer());
            //Мы вызваем метод run который задан у нас в контроллере для подгрузки и отображения шаблонов.
            //В него мы помещаем то имя которое прописывается в адресной строке или задаётся по умаолчанию
            //после чего происходит подгрузка шаблона.
                $controller->run($actionName);
        }else{
            //Иначе мы вызываем сообщение об ошибке если метод run сработал не правильно.
            echo '404';
        }
    }

    //Создаём магический метод чтобы при проверке элемента, проверялось не компонент ли это.
    function __get($name)
    {
        return $this->components->get($name);
    }

    //Создаём компонентов.
    public function createComponent($key)
    {
        //Ищем в массиве config  компонент по ключу
        if(isset($this->config['components'][$key])){
            //В переменную помещаем элемент компонента из конфига.
            $params = $this->config['components'][$key];
            //В переменную помещаем подмассив элемента с ключом class.
            $class = $params['class'];
            //Если такой класс существует
            if (class_exists($class)){
                //Удаляем копонент класс, потому что ни в одном конструкторе такого параметра не будет.
                unset($params['class']);
                //Чтобы получить данные о классе мы создаём специальный класс в который кладём экземпляр нашего объекта.
                $reflection = new \ReflectionClass($class);
                //Метод позволяет создать новый объект от класса котрый мы указали и передать параметры которые
                // в конструктор пойдут. В нашем случае эти параметры есть только в компоненте db.
                return $reflection->newInstanceArgs($params);
            }else{
                throw new \Exception("Не определён класс компонента!");
            }
        }else{
            throw new \Exception("Компонент {$key} не найден");
        }
    }

}